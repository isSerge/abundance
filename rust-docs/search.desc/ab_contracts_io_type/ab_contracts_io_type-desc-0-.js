searchState.loadedDescShard("ab_contracts_io_type", 0, "Trait that is used for types that are crossing host/guest …\nMarker trait, companion to <code>IoType</code> that indicates the …\nThe maximum alignment supported by <code>IoType</code> types (16 bytes, …\nData structure metadata in binary form, describing shape …\nPointer with trivial type that this <code>IoType</code> represents\nGet an exclusive raw pointer to the underlying data with …\nGet a raw pointer to the underlying data with no checks.\nNumber of bytes are allocated right now\nNumber of bytes are allocated right now\nCreate a mutable reference to a type, which is represented …\nCreate a reference to a type, which is represented by …\nSet the number of used bytes\nNumber of bytes that are currently used to store data\nAn exclusive pointer to the number of bytes that are …\nPointer to the number of bytes that are currently used to …\nJust like <code>bool</code>, but any bit pattern is valid.\nReturns the argument unchanged.\nGet the value\nCalls <code>U::from(self)</code>.\nCreate a new instance from existing boolean value\nSet new value\nContainer for storing a number of bytes limited by the …\nContainer for storing a number of bytes limited by the …\nAppend some bytes.\nAppend some bytes.\nCopy from specified bytes.\nCopy from specified bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAccess to stored bytes\nAccess to stored bytes\nExclusive access to stored bytes\nExclusive access to stored bytes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if length is zero\nReturns <code>true</code> if length is zero\nNumber of stored bytes\nNumber of stored bytes\nTruncate stored bytes to this length.\nTruncate stored bytes to this length.\nTry to create an instance from provided bytes.\nTry to create an instance from provided bytes.\nContainer for storing a UTF-8 string limited by the …\nContainer for storing a UTF-8 string limited by the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWrapper type for <code>Data</code> that may or may not be filled with …\nAssume value is initialized\nReturns the argument unchanged.\nCreate a new shared instance from provided data reference.\nCreate a new exclusive instance from provided data …\nCreate a new shared instance from provided memory buffer.\nTry to get access to initialized <code>Data</code>, returns <code>None</code> if not …\nTry to get exclusive access to initialized <code>Data</code>, returns …\nGet exclusive access to initialized <code>Data</code>, initializing …\nGet exclusive access to initialized <code>Data</code>, running provided …\nCalls <code>U::from(self)</code>.\nRemove <code>Data</code> inside and turn instance back into …\nInitialize by inserting <code>Data</code> by value or replace existing …\nAddress of a contract.\nArray <code>[T; N]</code> with up to 2^16 elements.\nArray <code>[T; N]</code> with up to 2^32 elements.\nArray <code>[T; N]</code> with up to 2^8 elements.\nCompact alias for <code>[u8; 1024]</code>\nCompact alias for <code>[u8; 128]</code>\nCompact alias for <code>[u8; 16]</code>\nCompact alias for <code>[u8; 2028]</code>\nCompact alias for <code>[u8; 256]</code>\nCompact alias for <code>[u8; 32]</code>\nCompact alias for <code>[u8; 4096]</code>\nCompact alias for <code>[u8; 512]</code>\nCompact alias for <code>[u8; 64]</code>\nCompact alias for <code>[u8; 8]</code>\nBalance of a token.\n<code>Bool</code>\n<code>enum E { Variant {..} }</code>\nSimilar to <code>Self::Enum</code>, but for exactly <code>1</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>10</code> enum variants …\nSimilar to <code>Self::Enum</code>, but for exactly <code>2</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>3</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>4</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>5</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>6</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>7</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>8</code> enum variants and …\nSimilar to <code>Self::Enum</code>, but for exactly <code>9</code> enum variants and …\n<code>enum E { A, B }</code>\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>1</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>10</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>2</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>3</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>4</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>5</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>6</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>7</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>8</code> enum …\nSimilar to <code>Self::EnumNoFields</code>, but for exactly <code>9</code> enum …\nFixed capacity bytes with up to 2^16 bytes capacity.\nFixed capacity bytes with up to 2^8 bytes capacity.\nFixed capacity UTF-8 bytes with up to 2^16 bytes capacity.\nFixed capacity UTF-8 string with up to 2^8 bytes capacity.\n<code>i128</code>\n<code>i16</code>\n<code>i32</code>\n<code>i64</code>\n<code>i8</code>\nMetadata types contained in <code>TrivialType::METADATA</code> and …\nMax capacity for metadata bytes used in fixed size buffers\n<code>struct S {..}</code>\nSimilar to <code>Self::Struct</code>, but for exactly <code>0</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>1</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>10</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>2</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>3</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>4</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>5</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>6</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>7</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>8</code> struct fields …\nSimilar to <code>Self::Struct</code>, but for exactly <code>9</code> struct fields …\n<code>struct S(..);</code>\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>1</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>10</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>2</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>3</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>4</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>5</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>6</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>7</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>8</code> struct …\nSimilar to <code>Self::TupleStruct</code>, but for exactly <code>9</code> struct …\n<code>u128</code>\n<code>u16</code>\n<code>u32</code>\n<code>u64</code>\n<code>u8</code>\n<code>()</code>\nCompact alias <code>VariableBytes&lt;0&gt;</code>\nCompact alias <code>VariableBytes&lt;1024&gt;</code>\nCompact alias <code>VariableBytes&lt;1048576&gt;</code>\nCompact alias <code>VariableBytes&lt;131072&gt;</code>\nCompact alias <code>VariableBytes&lt;16384&gt;</code>\nVariable bytes with up to 2^16 bytes recommended …\nCompact alias <code>VariableBytes&lt;2028&gt;</code>\nCompact alias <code>VariableBytes&lt;262144&gt;</code>\nCompact alias <code>VariableBytes&lt;32768&gt;</code>\nVariable bytes with up to 2^32 bytes recommended …\nCompact alias <code>VariableBytes&lt;4096&gt;</code>\nCompact alias <code>VariableBytes&lt;512&gt;</code>\nCompact alias <code>VariableBytes&lt;524288&gt;</code>\nCompact alias <code>VariableBytes&lt;65536&gt;</code>\nCompact alias <code>VariableBytes&lt;8192&gt;</code>\nVariable bytes with up to 2^8 bytes recommended allocation.\nCompact alias <code>VariableElements&lt;0, T&gt;</code>\nVariable elements with up to 2^16 elements recommended …\nVariable elements with up to 2^32 elements recommended …\nVariable elements with up to 2^8 elements recommended …\nAlignment of the type\nCreate an instance for regular bytes (alignment 1)\nProduce compact metadata.\nConcatenates metadata sources.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRecommended capacity that must be allocated by the host.\nTry to create an instance from its <code>u8</code> representation\nDecode type, return its recommended capacity that should …\nDecode type name.\nData structure metadata in binary form, describing shape …\nSimple wrapper data type that is designed in such a way …\nAccess the underlying byte representation of a data …\nAccess the underlying mutable byte representation of a …\nCreate a reference to a type, which is represented by …\nCreate a mutable reference to a type, which is represented …\nContainer for storing variable number of bytes.\nAppend some bytes by using more of allocated, but …\nGet exclusive access to the underlying pointer with no …\nAssume that the first <code>size</code> are initialized and can be read.\nCapacity in bytes\nCast an exclusive reference to this instance into a …\nCast a shared reference to this instance into a reference …\nCopy contents from another <code>IoType</code>.\nReturns the argument unchanged.\nCreate a new shared instance from provided memory buffer.\nCreate a new exclusive instance from provided memory …\nCreate a new shared instance from provided memory buffer.\nTry to get access to initialized bytes\nTry to get exclusive access to initialized <code>Data</code>, returns …\nCalls <code>U::from(self)</code>.\nReads and returns value of type <code>T</code> or <code>None</code> if there is not …\nTruncate internal initialized bytes to this size.\nContainer for storing variable number of elements.\nAppend some elements by using more of allocated, but …\nGet exclusive access to the underlying pointer with no …\nAssume that the first <code>size</code> are initialized and can be read.\nCapacity in bytes\nCast an exclusive reference to this instance into a …\nCast a shared reference to this instance into a reference …\nCopy contents from another instance.\nNumber of elements\nReturns the argument unchanged.\nCreate a new shared instance from provided memory buffer.\nCreate a new exclusive instance from provided memory …\nCreate a new shared instance from provided memory buffer.\nTry to get access to initialized elements\nTry to get exclusive access to initialized <code>Data</code>, returns …\nCalls <code>U::from(self)</code>.\nTruncate internal initialized bytes to this size.")