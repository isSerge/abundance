<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`#[contract]` macro to derive contract implementation."><title>contract in ab_contracts_macros - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-c233d2bd.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ab_contracts_macros" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0-nightly (d7ea436a0 2025-04-24)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ab_contracts_macros/index.html">ab_<wbr>contracts_<wbr>macros</a><span class="version">0.0.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">contract</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#for-struct-implementation" title="For struct implementation">For struct implementation</a><ul><li><a href="#init" title="#[init]">#[init]</a></li><li><a href="#update" title="#[update]">#[update]</a></li><li><a href="#view" title="#[view]">#[view]</a></li></ul></li><li><a href="#for-trait-definition-and-trait-implementation" title="For trait definition and trait implementation">For trait definition and trait implementation</a><ul><li><a href="#update-1" title="#[update]">#[update]</a></li><li><a href="#view-1" title="#[view]">#[view]</a></li></ul></li><li><a href="#generated-code" title="Generated code">Generated code</a><ul><li><a href="#contract-trait-implementation" title="`Contract` trait implementation"><code>Contract</code> trait implementation</a></li><li><a href="#ffi-function" title="FFI function">FFI function</a></li><li><a href="#internalargs-struct" title="`InternalArgs` struct"><code>InternalArgs</code> struct</a></li><li><a href="#externalargs-implementation" title="`ExternalArgs` implementation"><code>ExternalArgs</code> implementation</a></li><li><a href="#extension-trait" title="Extension trait">Extension trait</a></li><li><a href="#metadata" title="Metadata">Metadata</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate ab_<wbr>contracts_<wbr>macros</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">ab_contracts_macros</a></div><h1>Attribute Macro <span class="attr">contract</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>#[contract]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>#[contract]</code> macro to derive contract implementation.</p>
<p>This macro is supposed to be applied to an implementation of the struct that in turn implements
<a href="ab_contracts_io_type::IoType"><code>IoType</code></a> trait. <a href="ab_contracts_io_type::IoType"><code>IoType</code></a> is most commonly obtained by deriving <a href="ab_contracts_io_type::trivial_type::TrivialType"><code>TrivialType</code></a> (<a href="ab_contracts_io_type::IoType"><code>IoType</code></a>
is implemented for all types that implement <a href="ab_contracts_io_type::trivial_type::TrivialType"><code>TrivialType</code></a>).</p>
<p><code>#[contract]</code> macro will process <em>public</em> methods annotated with the following attributes:</p>
<ul>
<li><code>#[init]</code> - method that can be called to produce an initial state of the contract,
called once during contacts lifetime</li>
<li><code>#[update]</code> - method that can read and/or modify state and/or slots of the contact, may be
called by user transaction directly or by another contract</li>
<li><code>#[view]</code> - method that can only read blockchain data, can read state or slots of the
contract, but can’t modify their contents</li>
</ul>
<p>Each argument (except <code>self</code>) of these methods has to be annotated with one of the following
attributes (must be in this order):</p>
<ul>
<li><code>#[env]</code> - environment variable, used to access ephemeral execution environment, call methods
on other contracts, etc.</li>
<li><code>#[tmp]</code> - temporary ephemeral value to store auxiliary data while processing a transaction</li>
<li><code>#[slot]</code> - slot corresponding to this contract</li>
<li><code>#[input]</code> - method input coming from user transaction or invocation from another contract</li>
<li><code>#[output]</code> - method output, may serve as an alternative to returning values from a function
directly, useful to reduce stack usage</li>
</ul>
<h2 id="for-struct-implementation"><a class="doc-anchor" href="#for-struct-implementation">§</a>For struct implementation</h2><h3 id="init"><a class="doc-anchor" href="#init">§</a>#[init]</h3>
<p>Initializer’s purpose is to produce the initial state of the contract.</p>
<p>The following arguments are supported by this method (must be in this order):</p>
<ul>
<li><code>#[env]</code> read-only and read-write</li>
<li><code>#[tmp]</code> read-only and read-write</li>
<li><code>#[slot]</code> read-only and read-write</li>
<li><code>#[input]</code></li>
<li><code>#[output]</code></li>
</ul>
<p><code>self</code> argument is not supported in any way in this context since the state of the contract is
just being created.</p>
<h3 id="update"><a class="doc-anchor" href="#update">§</a>#[update]</h3>
<p>Generic method contract that can both update contract’s own state and contents of slots.</p>
<p>The following arguments are supported by this method (must be in this order):</p>
<ul>
<li><code>&amp;self</code> or <code>&amp;mut self</code> depending on whether state reads and/or modification are required</li>
<li><code>#[env]</code> read-only and read-write</li>
<li><code>#[tmp]</code> read-only and read-write</li>
<li><code>#[slot]</code> read-only and read-write</li>
<li><code>#[input]</code></li>
<li><code>#[output]</code></li>
</ul>
<h3 id="view"><a class="doc-anchor" href="#view">§</a>#[view]</h3>
<p>Similar to <code>#[update]</code>, but can only access read-only view of the state and slots, can be called
outside of block context and can only call other <code>#[view]</code> methods.</p>
<p>The following arguments are supported by this method (must be in this order):</p>
<ul>
<li><code>&amp;self</code></li>
<li><code>#[env]</code> read-only</li>
<li><code>#[slot]</code> read-only</li>
<li><code>#[input]</code></li>
<li><code>#[output]</code></li>
</ul>
<h2 id="for-trait-definition-and-trait-implementation"><a class="doc-anchor" href="#for-trait-definition-and-trait-implementation">§</a>For trait definition and trait implementation</h2><h3 id="update-1"><a class="doc-anchor" href="#update-1">§</a>#[update]</h3>
<p>Generic method contract that can (in case of trait indirectly) both update contract’s own state
and contents of slots.</p>
<p>The following arguments are supported by this method in trait context (must be in this order):</p>
<ul>
<li><code>#[env]</code> read-only and read-write</li>
<li><code>#[input]</code></li>
<li><code>#[output]</code></li>
</ul>
<h3 id="view-1"><a class="doc-anchor" href="#view-1">§</a>#[view]</h3>
<p>Similar to <code>#[update]</code>, but can only access (in case of trait indirectly) read-only view of the
state and slots, can be called outside of block context and can only call other <code>#[view]</code>
methods.</p>
<p>The following arguments are supported by this method in trait context (must be in this order):</p>
<ul>
<li><code>#[env]</code> read-only</li>
<li><code>#[input]</code></li>
<li><code>#[output]</code></li>
</ul>
<h2 id="generated-code"><a class="doc-anchor" href="#generated-code">§</a>Generated code</h2>
<p>This macro will produce several key outputs:</p>
<ul>
<li><a href="ab_contracts_common::Contract"><code>Contract</code></a> trait implementation (for struct implementation)</li>
<li>FFI function for every method, which can be used by the host to call into the guest
environment (for struct and trait implementation)</li>
<li><code>InternalArgs</code> struct corresponding to each method, used as its sole input for FFI function</li>
<li>Struct implementing <a href="ab_contracts_common::method::ExternalArgs"><code>ExternalArgs</code></a> trait for each method, usable by other contracts to call
into this contract through the host, host will interpret it based on metadata and generate
<code>InternalArgs</code> (for struct and trait implementation, trait definitions)</li>
<li>Extension trait (for struct and trait implementation) that simplifies interaction with host
and removes the need to construct <a href="ab_contracts_common::method::ExternalArgs"><code>ExternalArgs</code></a> manually, providing nice strongly typed
methods instead, implemented for <a href="ab_contracts_common::env::Env"><code>Env</code></a> struct (for struct and trait implementation, trait
definitions)</li>
<li>Metadata as defined in <a href="ab_contracts_common::metadata::ContractMetadataKind"><code>ContractMetadataKind</code></a> stored in <code>CONTRACT_METADATA</code> link section
when compiled with <code>guest</code> feature enabled (for method, struct and trait implementation)</li>
</ul>
<h3 id="contract-trait-implementation"><a class="doc-anchor" href="#contract-trait-implementation">§</a><a href="ab_contracts_common::Contract"><code>Contract</code></a> trait implementation</h3>
<p><a href="ab_contracts_common::Contract"><code>Contract</code></a> trait is required by a few other components in the system, so it is automatically
implemented by the macro, see trait details.</p>
<h3 id="ffi-function"><a class="doc-anchor" href="#ffi-function">§</a>FFI function</h3>
<p>Macro generates FFI function with C ABI that looks like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg_attr(feature = <span class="string">"guest"</span>, <span class="kw">unsafe</span>(no_mangle))]
</span><span class="kw">pub unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>{prefix}<span class="kw">_</span>{method}(
    args: NonNull&lt;InternalArgs&gt;,
) -&gt; ExitCode {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>Where <code>{prefix}</code> is derived from struct or trait name and <code>{method}</code> is the original method name
from struct or trait implementation.</p>
<p>Example with struct implementation:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// This
</span><span class="attr">#[contract]
</span><span class="kw">impl </span>Example {
    <span class="attr">#[view]
    </span><span class="kw">pub fn </span>hello() {}
}

<span class="comment">// Will generate this
</span><span class="attr">#[cfg_attr(feature = <span class="string">"guest"</span>, <span class="kw">unsafe</span>(no_mangle))]
</span><span class="kw">pub unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>example_hello(
    args: NonNull&lt;InternalArgs&gt;,
) -&gt; ExitCode {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>Example with trait implementation:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// This
</span><span class="attr">#[contract]
</span><span class="kw">impl </span>Fungible <span class="kw">for </span>Token {
    <span class="attr">#[view]
    </span><span class="kw">pub fn </span>balance(<span class="attr">#[slot] </span>address: <span class="kw-2">&amp;</span>Address) -&gt; Balance {}
}

<span class="comment">// Will generate this
</span><span class="attr">#[cfg_attr(feature = <span class="string">"guest"</span>, <span class="kw">unsafe</span>(no_mangle))]
</span><span class="kw">pub unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>fungible_balance(
    args: NonNull&lt;InternalArgs&gt;,
) -&gt; ExitCode {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>These generated functions are public and available in generated submodules, but there should
generally be no need to call them directly.</p>
<h3 id="internalargs-struct"><a class="doc-anchor" href="#internalargs-struct">§</a><code>InternalArgs</code> struct</h3>
<p><code>InternalArgs</code> is generated for each method and is used as input to the above FFI functions. Its
fields are generated based on function arguments, processing them in the same order as in
function signature. It is possible for host to build this data structure dynamically using
available contact metadata.</p>
<p>All fields in the data structure are pointers, some are read-only, some can be written to if
changes need to be communicated back to the host.</p>
<h4 id="self"><a class="doc-anchor" href="#self">§</a><code>&amp;self</code></h4>
<p><code>&amp;self</code> is a read-only state of the contract and generates two fields, both of which are
read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="kw">pub </span>state_ptr: NonNull&lt;&lt;StructName <span class="kw">as </span>IoType&gt;::PointerType&gt;,
    <span class="kw">pub </span>state_size: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>This allows a contract to read the current state of the contract.</p>
<h4 id="mut-self"><a class="doc-anchor" href="#mut-self">§</a><code>&amp;mut self</code></h4>
<p><code>&amp;mut self</code> is a read-write state of the contract and generates three fields, <code>state_ptr</code> and
<code>state_size</code> can be written to, while <code>state_capacity</code> is read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="kw">pub </span>state_ptr: NonNull&lt;&lt;StructName <span class="kw">as </span>IoType&gt;::PointerType&gt;,
    <span class="kw">pub </span>state_size: <span class="kw-2">*mut </span>u32,
    <span class="kw">pub </span>state_capacity: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>This allows a contract to not only read, but also change the current state of the contract.
<code>state_capacity</code> is defined by both the type used and the size of the value used (whichever is
bigger in case of a variable-sized types) and corresponds to the amount of memory that host
allocated for the guest behind <code>state_ptr</code>. In the case of a variable-sized types, guest can
replace<code>state_ptr</code> with a pointer to a guest-allocated region of memory that host must read
updated value from. This is helpful in case increase of the value size beyond allocated capacity
is needed.</p>
<h4 id="env-env-env"><a class="doc-anchor" href="#env-env-env">§</a><code>#[env] env: &amp;Env</code></h4>
<p><code>#[env] env: &amp;Env</code> is for accessing ephemeral environment with method calls restricted to
<code>#[view]</code>. Since this is a system-provided data structure with known layout, only read-only
pointer field is generated:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs&lt;<span class="lifetime">'internal_args</span>&gt; {
    <span class="comment">// ...
    </span><span class="kw">pub </span>env_ptr: NonNull&lt;Env&lt;<span class="lifetime">'internal_args</span>&gt;&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<h4 id="env-env-mut-env"><a class="doc-anchor" href="#env-env-mut-env">§</a><code>#[env] env: &amp;mut Env</code></h4>
<p><code>#[env] env: &amp;Env</code> is for accessing ephemeral environment without method calls restrictions.
Since this is a system-provided data structure with known layout, only read-write pointer field
is generated:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs&lt;<span class="lifetime">'internal_args</span>&gt; {
    <span class="comment">// ...
    </span><span class="kw">pub </span>env_ptr: NonNull&lt;Env&lt;<span class="lifetime">'internal_args</span>&gt;&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<h4 id="tmp-tmp-maybedatatmp"><a class="doc-anchor" href="#tmp-tmp-maybedatatmp">§</a><code>#[tmp] tmp: &amp;MaybeData&lt;Tmp&gt;</code></h4>
<p><code>#[tmp] tmp: &amp;MaybeData&lt;Tmp&gt;</code> is for accessing ephemeral value with auxiliary data and generates
two fields, both of which are read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>tmp_ptr: NonNull&lt;
        &lt;
            &lt;StructName <span class="kw">as </span>Contract&gt;::Tmp <span class="kw">as </span>IoType
        &gt;::PointerType,
    &gt;,
    <span class="kw">pub </span>tmp_size: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>This allows a contract to read the current ephemeral value of the contract.</p>
<h4 id="tmp-tmp-mut-maybedatatmp"><a class="doc-anchor" href="#tmp-tmp-mut-maybedatatmp">§</a><code>#[tmp] tmp: &amp;mut MaybeData&lt;Tmp&gt;</code></h4>
<p><code>#[tmp] tmp: &amp;MaybeData&lt;Tmp&gt;</code> is for accessing ephemeral value with auxiliary data and generates
three fields, <code>tmp_ptr</code> and <code>tmp_size</code> can be written to, while <code>tmp_capacity</code> is read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>tmp_ptr: NonNull&lt;
        &lt;
            &lt;StructName <span class="kw">as </span>Contract&gt;::Tmp <span class="kw">as </span>IoType
        &gt;::PointerType,
    &gt;,
    <span class="kw">pub </span>tmp_size: <span class="kw-2">*mut </span>u32,
    <span class="kw">pub </span>tmp_capacity: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>This allows a contract to not only read, but also change the ephemeral value of the contract.
<code>tmp_capacity</code> is defined by both the type used and the size of the value used (whichever is
bigger in case of a variable-sized types) and corresponds to the amount of memory that host
allocated for the guest behind <code>tmp_ptr</code>. In the case of a variable-sized types, guest can
replace<code>tmp_ptr</code> with a pointer to a guest-allocated region of memory that host must read
updated value from. This is helpful in case increase of the value size beyond allocated capacity
is needed.</p>
<h4 id="slot-slot-maybedataslot-and-slot-address-slot-address-maybedataslot"><a class="doc-anchor" href="#slot-slot-maybedataslot-and-slot-address-slot-address-maybedataslot">§</a><code>#[slot] slot: &amp;MaybeData&lt;Slot&gt;</code> and <code>#[slot] (address, slot): (&amp;Address, &amp;MaybeData&lt;Slot&gt;)</code></h4>
<p><code>#[slot] slot: &amp;MaybeData&lt;Slot&gt;</code> and its variant with explicit address argument are for
accessing slot data (that corresponds to optional <code>address</code> argument) and generates 3 fields,
all of which are read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>slot_address_ptr: NonNull&lt;Address&gt;,
    <span class="kw">pub </span>slot_ptr: NonNull&lt;
        &lt;
            &lt;StructName <span class="kw">as </span>Contract&gt;::Slot <span class="kw">as </span>IoType
        &gt;::PointerType,
    &gt;,
    <span class="kw">pub </span>slot_size: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>This allows a contract to read slot data.</p>
<h4 id="slot-slot-mut-maybedataslot-and-slot-address-slot-address-mut-maybedataslot"><a class="doc-anchor" href="#slot-slot-mut-maybedataslot-and-slot-address-slot-address-mut-maybedataslot">§</a><code>#[slot] slot: &amp;mut MaybeData&lt;Slot&gt;</code> and <code>#[slot] (address, slot): (&amp;Address, &amp;mut MaybeData&lt;Slot&gt;)</code></h4>
<p><code>#[slot] slot: &amp;mut MaybeData&lt;Slot&gt;</code> and its variant with explicit address argument are for
accessing slot data (that corresponds to optional <code>address</code> argument) and generates 4 fields,
<code>slot_ptr</code> and <code>slot_size</code> can be written to, while <code>slot_address_ptr</code> and <code>slot_capacity</code> are
read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>slot_address_ptr: NonNull&lt;Address&gt;,
    <span class="kw">pub </span>slot_ptr: NonNull&lt;
        &lt;
            &lt;StructName <span class="kw">as </span>Contract&gt;::Slot <span class="kw">as </span>IoType
        &gt;::PointerType,
    &gt;,
    <span class="kw">pub </span>slot_size: <span class="kw-2">*mut </span>u32,
    <span class="kw">pub </span>slot_capacity: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>This allows a contract to not only read, but also change slot data.
<code>slot_capacity</code> is defined by both the type used and the size of the value used (whichever is
bigger in case of a variable-sized types) and corresponds to the amount of memory that host
allocated for the guest behind <code>slot_ptr</code>. In the case of a variable-sized types, guest can
replace<code>slot_ptr</code> with a pointer to a guest-allocated region of memory that host must read
updated value from. This is helpful in case increase of the value size beyond allocated capacity
is needed.</p>
<p>Slot changes done by the method call will not be persisted if it returns an error.</p>
<h4 id="input-input-inputvalue"><a class="doc-anchor" href="#input-input-inputvalue">§</a><code>#[input] input: &amp;InputValue</code></h4>
<p><code>#[input] input: &amp;InputValue</code> is a read-only input to the contract call and generates two
fields, both of which are read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>input_ptr: NonNull&lt;&lt;InputValue <span class="kw">as </span>IoType&gt;::PointerType&gt;,
    <span class="kw">pub </span>input_size: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<h4 id="output-output-mut-maybedataoutputvalue-and---returnvalue--resultreturnvalue-contracterror"><a class="doc-anchor" href="#output-output-mut-maybedataoutputvalue-and---returnvalue--resultreturnvalue-contracterror">§</a><code>#[output] output: &amp;mut MaybeData&lt;OutputValue&gt;</code> and <code>-&gt; ReturnValue</code>/<code>-&gt; Result&lt;ReturnValue, ContractError&gt;</code></h4>
<p><code>#[output] output: &amp;mut MaybeData&lt;OutputValue&gt;</code> and regular return value is a read-write output
to the contract call and generates tree fields, <code>output_ptr</code> and <code>output_size</code> can be written
to, while <code>output_capacity</code> is read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>InternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>output_ptr: NonNull&lt;&lt;OutputValue <span class="kw">as </span>IoType&gt;::PointerType&gt;,
    <span class="kw">pub </span>output_size: <span class="kw-2">*mut </span>u32,
    <span class="kw">pub </span>output_capacity: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>Initially output is empty, but contract can write something useful there and written value will
be propagated back to the caller to observe. <code>output_ptr</code> pointer <em>must not be changed</em> as the
host will not follow it to the new address, the output size is fully constrained by capacity
specified in <code>output_capacity</code>. The only exception is the last <code>#[output]</code> of <code>#[init]</code> method
(or <code>ReturnValue</code> if present), which is the contract’s initial state. In this case, its pointer
can be changed to point to a different data structure and not being limited by <code>result_capacity</code>
allocation from the host.</p>
<p>NOTE: Even in case the method call fails, the host may modify the contents of the output.</p>
<p><code>#[output]</code> may be used as an alternative to <code>-&gt; ReturnValue</code> and
<code>-&gt; Result&lt;ReturnValue, ContractError&gt;</code> in case the data structure is large and allocation on
the stack is undesirable, which is especially helpful in case of a variable-sized contract
state.</p>
<p>NOTE: In case <code>ReturnValue</code> in <code>-&gt; ReturnValue</code> or <code>-&gt; Result&lt;ReturnValue, ContractError&gt;</code> is
<code>()</code>, it will be skipped in <code>InternalArgs</code>.</p>
<h3 id="externalargs-implementation"><a class="doc-anchor" href="#externalargs-implementation">§</a><a href="ab_contracts_common::method::ExternalArgs"><code>ExternalArgs</code></a> implementation</h3>
<p>Macro generates a struct that implements <a href="ab_contracts_common::method::ExternalArgs"><code>ExternalArgs</code></a> for each method that other contracts
give to the host when they want to call into another (or even the same) contract.</p>
<p>Here is an example with struct implementation, but it works the same way with trait definition
and implementation too:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// This
</span><span class="attr">#[contract]
</span><span class="kw">impl </span>Example {
    <span class="attr">#[view]
    </span><span class="kw">pub fn </span>hello() {}
}

<span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>ExampleHelloArgs {
    <span class="comment">// ...
</span>}

<span class="attr">#[automatically_derived]
</span><span class="kw">unsafe impl </span>ExternalArgs <span class="kw">for </span>ExampleHelloArgs {
    <span class="comment">// ...
</span>}

<span class="kw">impl </span>ExternalArgs {
    <span class="kw">pub fn </span>new(
        <span class="comment">// ...
    </span>) -&gt; <span class="self">Self </span>{
        <span class="comment">// ...
    </span>}
}</code></pre></div>
<p>Struct name if generated by concatenating struct or trait name on which name wsa generated,
method name and <code>Args</code> suffix, which is done to make it more convenient to use externally.</p>
<p><code>&amp;self</code>, <code>&amp;mut self</code>, <code>#[env]</code> and <code>#[tmp]</code> arguments of the method are controlled fully by the
host and not present in <code>ExternalArgs</code>.</p>
<p><code>ExternalArgs::new()</code> method is generated for convenient construction of the instance, though in
most cases <a href="#extension-trait">Extension trait</a> is used with more convenient API.</p>
<h4 id="slot"><a class="doc-anchor" href="#slot">§</a><code>#[slot]</code></h4>
<p>Each <code>#[slot]</code> argument in <code>ExternalArgs</code> is represented by a single read-only address pointer:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>ExternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>slot_ptr: NonNull&lt;Address&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<h4 id="input"><a class="doc-anchor" href="#input">§</a><code>#[input]</code></h4>
<p>Each <code>#[input]</code> argument in <code>ExternalArgs</code> is represented by two read-only fields, pointer to
data and its size:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>ExternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>input_ptr: NonNull&lt;&lt;InputValue <span class="kw">as </span>IoType&gt;::PointerType&gt;,
    <span class="kw">pub </span>input_size: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<h4 id="output-and---returnvalue--resultreturnvalue-contracterror"><a class="doc-anchor" href="#output-and---returnvalue--resultreturnvalue-contracterror">§</a><code>#[output]</code> and <code>-&gt; ReturnValue</code>/<code>-&gt; Result&lt;ReturnValue, ContractError&gt;</code></h4>
<p>Each <code>#[output]</code> argument in <code>ExternalArgs</code> is represented by three fields, <code>output_ptr</code> and
<code>output_size</code> can be written to, while <code>output_capacity</code> is read-only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(C)]
</span><span class="kw">pub struct </span>ExternalArgs {
    <span class="comment">// ...
    </span><span class="kw">pub </span>output_ptr: NonNull&lt;&lt;OutputValue <span class="kw">as </span>IoType&gt;::PointerType&gt;,
    <span class="kw">pub </span>output_size: <span class="kw-2">*mut </span>u32,
    <span class="kw">pub </span>output_capacity: NonNull&lt;u32&gt;,
    <span class="comment">// ...
</span>}</code></pre></div>
<p>The arguments are skipped in <code>ExternalArgs</code> for the last <code>#[output]</code> or <code>ReturnValue</code> when
method is <code>#[init]</code> or when <code>ReturnValue</code> is <code>()</code> in other cases. For <code>#[init]</code> method’s return
value is contract’s initial state and is processed by execution environment itself. When
<code>ReturnValue</code> is <code>()</code> then there is no point in having a pointer for it.</p>
<h3 id="extension-trait"><a class="doc-anchor" href="#extension-trait">§</a>Extension trait</h3>
<p>Extension trait is just a convenient wrapper, whose safe methods take strongly typed arguments,
construct <code>ExternalArgs</code> while respecting Rust safety invariants and calls <a href="ab_contracts_common::env::Env::call()"><code>Env::call()</code></a> with
it. Extension trait usage is not mandatory, but it does make method calls much more convenient
in most simple cases.</p>
<p>Generated methods reflect <code>ExternalArgs</code> fields with just context (except when calling <code>#[view]</code>
method where context is not applicable) and the address of the contract being called added at
the beginning:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// This
</span><span class="kw">impl </span>Token {
    <span class="comment">// ...

    </span><span class="attr">#[view]
    </span><span class="kw">pub fn </span>balance(<span class="attr">#[slot] </span>target: <span class="kw-2">&amp;</span>MaybeData&lt;Slot&gt;) -&gt; Balance {
        <span class="comment">// ...
    </span>}

    <span class="attr">#[update]
    </span><span class="kw">pub fn </span>transfer(
        <span class="attr">#[env] </span>env: <span class="kw-2">&amp;mut </span>Env&lt;<span class="lifetime">'_</span>&gt;,
        <span class="attr">#[slot] </span>(from_address, from): (<span class="kw-2">&amp;</span>Address, <span class="kw-2">&amp;mut </span>MaybeData&lt;Slot&gt;),
        <span class="attr">#[slot] </span>to: <span class="kw-2">&amp;mut </span>MaybeData&lt;Slot&gt;,
        <span class="attr">#[input] </span><span class="kw-2">&amp;</span>amount: <span class="kw-2">&amp;</span>Balance,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), ContractError&gt; {
        <span class="comment">// ...
    </span>}
}

<span class="comment">// Will generate this
</span><span class="kw">pub trait </span>TokenExt {
    <span class="kw">fn </span>balance(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        contract: <span class="kw-2">&amp;</span>Address,
        target: <span class="kw-2">&amp;</span>Address,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;Balance, ContractError&gt;;

    <span class="kw">fn </span>transfer(
        <span class="self">self</span>: &amp;&amp;<span class="kw-2">mut </span><span class="self">Self</span>,
        method_context: <span class="kw-2">&amp;</span>MethodContext,
        contract: <span class="kw-2">&amp;</span>Address,
        from: <span class="kw-2">&amp;</span>Address,
        to: <span class="kw-2">&amp;</span>Address,
        amount: <span class="kw-2">&amp;</span>Balance,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), ContractError&gt;;
}

<span class="kw">impl </span>TokenExt <span class="kw">for </span>Env {
    <span class="kw">fn </span>balance(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        contract: <span class="kw-2">&amp;</span>Address,
        target: <span class="kw-2">&amp;</span>Address,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;Balance, ContractError&gt; {
        <span class="comment">// ...
    </span>}

    <span class="kw">fn </span>transfer(
        <span class="self">self</span>: &amp;&amp;<span class="kw-2">mut </span><span class="self">Self</span>,
        method_context: <span class="kw-2">&amp;</span>MethodContext,
        contract: <span class="kw-2">&amp;</span>Address,
        from: <span class="kw-2">&amp;</span>Address,
        to: <span class="kw-2">&amp;</span>Address,
        amount: <span class="kw-2">&amp;</span>Balance,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), ContractError&gt; {
        <span class="comment">// ...
    </span>}
}</code></pre></div>
<p>The name of the extension trait is created as struct or trait name followed by <code>Ext</code> suffix.</p>
<h3 id="metadata"><a class="doc-anchor" href="#metadata">§</a>Metadata</h3>
<p>There are several places where metadata is being generated, see <a href="ab_contracts_common::metadata::ContractMetadataKind"><code>ContractMetadataKind</code></a> for
details.</p>
<p>First, <code>#[contract]</code> macro generates a public <code>METADATA</code> constant for each method individually.</p>
<p>Second, for each trait that contract can implement <code>#[contract]</code> macro generates an associated
constant <code>METADATA</code> that essentially aggregates metadata of all annotated methods.</p>
<p>Third, <a href="ab_contracts_common::Contract"><code>Contract</code></a> trait implementation generated by <code>#[contract]</code> macro contains
<code>MAIN_CONTRACT_METADATA</code> associated constant, which is similar in nature to <code>METADATA</code> constant
for traits described above.</p>
<p>Lastly, for the whole contract as a project, both trait and contract metadata is concatenated
and stored in <code>CONTRACT_METADATA</code> link section that can later be inspected externally to
understand everything about contract’s interfaces, auto-generate UI, etc.</p>
</div></details></section></div></main></body></html>