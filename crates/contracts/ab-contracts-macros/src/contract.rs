mod init;
mod methods;
mod update;
mod view;

use crate::contract::init::process_init_fn;
use crate::contract::methods::{ExtTraitComponents, MethodDetails};
use crate::contract::update::process_update_fn;
use crate::contract::view::process_view_fn;
use proc_macro2::{Ident, Literal, TokenStream, TokenTree};
use quote::{format_ident, quote};
use std::collections::HashMap;
use syn::spanned::Spanned;
use syn::{parse, Error, ImplItem, ImplItemFn, ItemImpl, Meta, Type, Visibility};

#[derive(Default)]
struct MethodOutput {
    guest_ffi: TokenStream,
    trait_ext_components: ExtTraitComponents,
}

struct Method {
    /// As authored in source code
    original_ident: Ident,
    methods_details: MethodDetails,
}

#[derive(Default)]
struct ContractDetails {
    methods: Vec<Method>,
}

pub(super) fn contract_impl(
    _attr: proc_macro::TokenStream,
    item: proc_macro::TokenStream,
) -> Result<proc_macro::TokenStream, Error> {
    let mut item_impl = parse::<ItemImpl>(item)?;
    let struct_name = item_impl.self_ty.as_ref();

    if let Some(trait_) = item_impl.trait_ {
        return Err(Error::new(
            trait_.1.span(),
            "`#[contract_impl]` is not applicable to trait implementations",
        ));
    }

    if !item_impl.generics.params.is_empty() {
        return Err(Error::new(
            item_impl.generics.span(),
            "`#[contract_impl]` is not applicable to generic implementations",
        ));
    }

    let mut guest_ffis = Vec::with_capacity(item_impl.items.len());
    let mut trait_ext_components = Vec::with_capacity(item_impl.items.len());
    let mut contract_details = ContractDetails::default();

    for item in &mut item_impl.items {
        if let ImplItem::Fn(impl_item_fn) = item {
            let method_output = process_fn(struct_name, impl_item_fn, &mut contract_details)?;
            guest_ffis.push(method_output.guest_ffi);
            trait_ext_components.push(method_output.trait_ext_components);
        }
    }

    let same_slot_types = MethodDetails::same_slot_types(
        contract_details
            .methods
            .iter()
            .map(|method| &method.methods_details),
    );
    if !same_slot_types {
        return Err(Error::new(
            item_impl.span(),
            "All `#[slot]` arguments must be of the same type",
        ));
    }

    let metadata = {
        let num_methods = u8::try_from(contract_details.methods.len()).map_err(|_error| {
            Error::new(
                item_impl.span(),
                format!("Struct can't have more than {} methods", u8::MAX),
            )
        })?;
        let num_methods = TokenTree::Literal(Literal::u8_unsuffixed(num_methods));
        let methods = contract_details
            .methods
            .iter()
            .map(|method| &method.original_ident);

        // Encodes the following:
        // * Number of methods
        // * Metadata of methods
        quote! {
            /// Contract metadata
            ///
            /// Enabled with `guest` feature to appear in the final binary, also prevents from
            /// `guest` feature being enabled in dependencies at the same time since that'll cause
            /// duplicated symbols.
            ///
            /// See [`#struct_name::CONTRACT_METADATA`] for details.
            #[cfg(feature = "guest")]
            #[used]
            #[unsafe(no_mangle)]
            static CONTRACT_METADATA: [u8; #struct_name::CONTRACT_METADATA.len()] =
                unsafe { *#struct_name::CONTRACT_METADATA.as_ptr().cast() };

            impl #struct_name {
                /// Contract metadata, starts with number of methods with their metadata next, see
                /// [`ContractMethodMetadata`](::ab_contracts_common::ContractMethodMetadata) for
                /// encoding details
                pub const CONTRACT_METADATA: &[u8] = {
                    const fn metadata() -> ([u8; 4096], usize) {
                        ::ab_contracts_io_type::utils::concat_metadata_sources(&[
                            &[#num_methods],
                            #( ffi::#methods::METADATA, )*
                        ])
                    }

                    // // Strange syntax to allow Rust to extend lifetime of metadata scratch automatically
                    metadata()
                        .0
                        .split_at(metadata().1)
                        .0
                };
            }
        }
    };

    let ext_trait = generate_extension_trait(struct_name, &trait_ext_components)?;

    let output = quote! {
        #item_impl

        #metadata

        #ext_trait

        /// FFI code generated by procedural macro
        pub mod ffi {
            use super::*;

            #( #guest_ffis )*
        }

        // Prevent macro from being called more than once in the same module at least
        const _CONTRACT_DEFINED: () = ();
    };

    Ok(output.into())
}

fn process_fn(
    struct_name: &Type,
    impl_item_fn: &mut ImplItemFn,
    contract_details: &mut ContractDetails,
) -> Result<MethodOutput, Error> {
    let supported_attrs = HashMap::<_, fn(_, _, _) -> _>::from_iter([
        (format_ident!("init"), process_init_fn as _),
        (format_ident!("update"), process_update_fn as _),
        (format_ident!("view"), process_view_fn as _),
    ]);
    let mut attrs = impl_item_fn.attrs.extract_if(.., |attr| match &attr.meta {
        Meta::Path(path) => {
            path.leading_colon.is_none()
                && path.segments.len() == 1
                && supported_attrs.contains_key(&path.segments[0].ident)
        }
        Meta::List(_meta_list) => false,
        Meta::NameValue(_meta_name_value) => false,
    });

    let Some(attr) = attrs.next() else {
        drop(attrs);

        // Return unmodified original if no recognized arguments are present
        return Ok(MethodOutput::default());
    };

    if let Some(next_attr) = attrs.take(1).next() {
        return Err(Error::new(
            next_attr.span(),
            "Function can only have one of `#[init]`, `#[update]` or `#[view]` attributes specified",
        ));
    }

    // Make sure function is public
    if !matches!(impl_item_fn.vis, Visibility::Public(_)) {
        return Err(Error::new(
            impl_item_fn.sig.span(),
            format!(
                "Function with `#[{}]` attribute must be public",
                attr.meta.path().segments[0].ident
            ),
        ));
    }

    // Make sure function doesn't have customized ABI
    if let Some(abi) = &impl_item_fn.sig.abi {
        return Err(Error::new(
            abi.span(),
            format!(
                "Function with `#[{}]` attribute must have default ABI",
                attr.meta.path().segments[0].ident
            ),
        ));
    }

    let processor = supported_attrs
        .get(&attr.path().segments[0].ident)
        .expect("Matched above to be one of the supported attributes; qed");
    processor(struct_name.clone(), impl_item_fn, contract_details)
}

fn generate_extension_trait(
    struct_name: &Type,
    trait_ext_components: &[ExtTraitComponents],
) -> Result<TokenStream, Error> {
    let struct_name = {
        let Type::Path(type_path) = struct_name else {
            return Err(Error::new(
                struct_name.span(),
                "`#[contract_impl]` must be applied to simple trait implementation",
            ));
        };
        let Some(struct_name) = type_path.path.get_ident() else {
            return Err(Error::new(
                struct_name.span(),
                "`#[contract_impl]` must be applied to simple trait implementation",
            ));
        };
        struct_name
    };

    let trait_name = format_ident!("{struct_name}Ext");
    let trait_doc = format!(
        "Extension trait that provides helper methods for calling [`{struct_name}`]'s methods on \
        [`Env`](::ab_contracts_common::env::Env) for convenience purposes"
    );
    let definitions = trait_ext_components
        .iter()
        .map(|components| &components.definitions);
    let impls = trait_ext_components
        .iter()
        .map(|components| &components.impls);

    Ok(quote! {
        use ffi::*;

        #[doc = #trait_doc]
        pub trait #trait_name {
            #( #definitions )*
        }

        impl #trait_name for ::ab_contracts_common::env::Env {
            #( #impls )*
        }
    })
}
