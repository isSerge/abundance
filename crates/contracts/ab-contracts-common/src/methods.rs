use const_sha1::sha1;

/// Hash of method's compact metadata
#[derive(Debug, Copy, Clone)]
#[repr(C)]
pub struct MethodFingerprint([u8; 32]);

impl MethodFingerprint {
    /// Create new method fingerprint from its metadata
    pub const fn new(method_metadata: &[u8]) -> Self {
        // TODO: Compact metadata
        // TODO: Switch to blake3 once https://github.com/BLAKE3-team/BLAKE3/pull/439 is upstreamed
        //  and const hashing version is exposed
        let hash = sha1(method_metadata).as_bytes();

        Self([
            hash[0], hash[1], hash[2], hash[3], hash[4], hash[5], hash[6], hash[7], hash[8],
            hash[9], hash[10], hash[11], hash[12], hash[13], hash[14], hash[15], hash[16],
            hash[17], hash[18], hash[19], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ])
    }
}

/// Marker trait for external arguments when calling methods.
///
/// # Safety
/// Struct that implements this trait must be `#[repr(C)]` and valid `ExternalArgs` for the contract
/// method being invoked.
///
/// **Do not implement this type explicitly!** It implementation is automatically generated by the
/// macro which generates smart contract implementation.
pub unsafe trait ExternalArgs {
    /// Fingerprint of the method being called
    const FINGERPRINT: MethodFingerprint;
}
