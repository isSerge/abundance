#![feature(non_null_from_ref)]
#![no_std]

pub mod env;
pub mod metadata;
pub mod method;

use crate::method::MethodFingerprint;
use ab_contracts_io_type::IoType;
use ab_contracts_io_type::trivial_type::TrivialType;
use ab_contracts_io_type::variable_bytes::VariableBytes;
use core::ffi::c_void;
use core::num::{NonZeroU32, NonZeroU128};
use core::ops::Deref;
use core::ptr::NonNull;
use derive_more::{
    Add, AddAssign, Display, Div, DivAssign, From, Into, Mul, MulAssign, Sub, SubAssign,
};

/// Max allowed size of the contract code
pub const MAX_CODE_SIZE: u32 = 1024 * 1024;

/// Pointers to methods of all contracts.
///
/// `fn_pointer`'s argument is actually `NonNull<InternalArgs>` of corresponding method and must
/// have corresponding ABI.
///
/// NOTE: It is unlikely to be necessary to interact with this directly.
#[derive(Debug, Copy, Clone)]
#[cfg(any(unix, windows))]
pub struct ContractsMethodsFnPointer {
    pub contact_code: &'static str,
    pub main_contract_metadata: &'static [u8],
    pub method_fingerprint: &'static MethodFingerprint,
    pub method_metadata: &'static [u8],
    pub ffi_fn: unsafe extern "C" fn(NonNull<NonNull<c_void>>) -> ExitCode,
}

#[cfg(any(unix, windows))]
inventory::collect!(ContractsMethodsFnPointer);

/// A trait that indicates the struct is a contact.
///
/// **Do not implement this trait explicitly!** Implementation is automatically generated by the
/// macro which generates smart contract implementation. This trait is required, but not sufficient
/// for proper contract implementation, use `#[contract]` attribute macro instead.
pub trait Contract: IoType {
    /// Main contract metadata, see [`ContractMetadataKind`] for encoding details.
    ///
    /// More metadata can be contributed by trait implementations.
    ///
    /// [`ContractMetadataKind`]: crate::metadata::ContractMetadataKind
    const MAIN_CONTRACT_METADATA: &[u8];
    /// Something that can be used as "code" in native execution environment
    #[cfg(any(unix, windows))]
    #[doc(hidden)]
    const CODE: &str;
    // Default value is provided to only fail to compile when contract that uses
    // `ab-contracts-common` has feature specified, but `ab-contracts-common` does not, but not the
    // other way around (as will be the case with dependencies where `guest` feature must not be
    // enabled)
    #[cfg(feature = "guest")]
    #[doc(hidden)]
    const GUEST_FEATURE_ENABLED: () = ();
    /// Slot type used by this contract
    type Slot: IoType;
    /// Tmp type used by this contract
    type Tmp: IoType;
    /// Something that can be used as "code" in native execution environment
    // TODO: Make `const` when possible
    #[cfg(any(unix, windows))]
    fn code() -> impl Deref<Target = VariableBytes<MAX_CODE_SIZE>>;
}

#[derive(Debug, Display, Copy, Clone, Hash, Ord, PartialOrd, Eq, PartialEq)]
#[repr(u8)]
pub enum ContractError {
    BadInput = 1,
    BadOutput,
    Forbidden,
    NotFound,
    Conflict,
    PreconditionFailed,
    InternalError = 128,
    NotImplemented,
}

impl ContractError {
    /// Convert contact error into contract exit code.
    ///
    /// Mosty useful for low-level code.
    #[inline]
    pub const fn exit_code(self) -> ExitCode {
        match self {
            Self::BadInput => ExitCode::BadInput,
            Self::BadOutput => ExitCode::BadOutput,
            Self::Forbidden => ExitCode::Forbidden,
            Self::NotFound => ExitCode::NotFound,
            Self::Conflict => ExitCode::Conflict,
            Self::PreconditionFailed => ExitCode::PreconditionFailed,
            Self::InternalError => ExitCode::InternalError,
            Self::NotImplemented => ExitCode::NotImplemented,
        }
    }
}

#[derive(Debug, Display, Copy, Clone, Hash, Ord, PartialOrd, Eq, PartialEq)]
#[repr(u8)]
#[must_use = "Code can be Ok or one of the errors, consider converting to Result<(), ContractCode>"]
pub enum ExitCode {
    Ok = 0,
    BadInput = 1,
    BadOutput,
    Forbidden,
    NotFound,
    Conflict,
    PreconditionFailed,
    InternalError = 128,
    NotImplemented,
}

impl From<ContractError> for ExitCode {
    #[inline]
    fn from(error: ContractError) -> Self {
        error.exit_code()
    }
}

impl From<Result<(), ContractError>> for ExitCode {
    #[inline]
    fn from(error: Result<(), ContractError>) -> Self {
        match error {
            Ok(()) => Self::Ok,
            Err(error) => error.exit_code(),
        }
    }
}

impl From<ExitCode> for Result<(), ContractError> {
    #[inline]
    fn from(value: ExitCode) -> Self {
        match value {
            ExitCode::Ok => Ok(()),
            ExitCode::BadInput => Err(ContractError::BadInput),
            ExitCode::BadOutput => Err(ContractError::BadOutput),
            ExitCode::Forbidden => Err(ContractError::Forbidden),
            ExitCode::NotFound => Err(ContractError::NotFound),
            ExitCode::Conflict => Err(ContractError::Conflict),
            ExitCode::PreconditionFailed => Err(ContractError::PreconditionFailed),
            ExitCode::InternalError => Err(ContractError::InternalError),
            ExitCode::NotImplemented => Err(ContractError::NotImplemented),
        }
    }
}

#[derive(
    Debug,
    Display,
    Default,
    Copy,
    Clone,
    Ord,
    PartialOrd,
    Eq,
    PartialEq,
    Add,
    AddAssign,
    Sub,
    SubAssign,
    Mul,
    MulAssign,
    Div,
    DivAssign,
    From,
    Into,
    TrivialType,
)]
#[repr(transparent)]
pub struct Balance(u128);

impl Balance {
    pub const MIN: Self = Self(0);
    pub const MAX: Self = Self(u128::MAX);
}

/// Shard index
#[derive(Debug, Display, Copy, Clone, Hash, Ord, PartialOrd, Eq, PartialEq, TrivialType)]
#[repr(transparent)]
pub struct ShardIndex(u32);

impl ShardIndex {
    /// Max possible shard index
    pub const MAX_SHARD_INDEX: u32 = Self::MAX_SHARDS.get() - 1;
    /// Max possible number of shards
    pub const MAX_SHARDS: NonZeroU32 = NonZeroU32::new(2u32.pow(20)).expect("Not zero; qed");
    /// Max possible number of addresses per shard
    pub const MAX_ADDRESSES_PER_SHARD: NonZeroU128 =
        NonZeroU128::new((u128::MAX / 2 + 1) / (Self::MAX_SHARDS.get() as u128 / 2))
            .expect("Not zero; qed");

    // TODO: Remove once traits work in const environment and `From` could be used
    /// Convert shard index to `u32`.
    ///
    /// This is typically only necessary for low-level code.
    pub const fn to_u32(self) -> u32 {
        self.0
    }

    // TODO: Remove once traits work in const environment and `From` could be used
    /// Create shard index from `u32`.
    ///
    /// Returns `None` if `shard_index > ShardIndex::MAX_SHARD_INDEX`
    ///
    /// This is typically only necessary for low-level code.
    pub const fn from_u32(shard_index: u32) -> Option<Self> {
        if shard_index > Self::MAX_SHARD_INDEX {
            return None;
        }

        Some(Self(shard_index))
    }
}

#[derive(Debug, Display, Copy, Clone, Hash, Ord, PartialOrd, Eq, PartialEq, TrivialType)]
#[repr(transparent)]
pub struct Address(u128);

impl PartialEq<&Address> for Address {
    #[inline]
    fn eq(&self, other: &&Address) -> bool {
        self.0 == other.0
    }
}

impl PartialEq<Address> for &Address {
    #[inline]
    fn eq(&self, other: &Address) -> bool {
        self.0 == other.0
    }
}

impl From<u128> for Address {
    #[inline]
    fn from(value: u128) -> Self {
        Self(value)
    }
}

// TODO: Method for getting creation shard out of the address
// TODO: There should be a notion of global address
impl Address {
    // TODO: Various system contracts
    /// Sentinel contract address, inaccessible and not owned by anyone
    pub const NULL: Self = Self(0);
    /// System contract for managing code of other contracts
    pub const SYSTEM_CODE: Self = Self(1);
    /// System contract for managing state of other contracts
    pub const SYSTEM_STATE: Self = Self(2);

    /// System contract for address allocation on a particular shard index
    #[inline]
    pub const fn system_address_allocator(shard_index: ShardIndex) -> Address {
        // Shard `0` doesn't have its own allocator because there are no user-deployable contracts
        // there, so address `0` is `NULL`, the rest up to `ShardIndex::MAX_SHARD_INDEX` correspond
        // to address allocators of respective shards
        Address(shard_index.to_u32() as u128 * ShardIndex::MAX_ADDRESSES_PER_SHARD.get())
    }
}
